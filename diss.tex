\documentclass[a4paper, 10pt]{article}
\usepackage[margin=1.5in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{biblatex}
\usepackage{amsthm}
\usepackage{tikz}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{array}
\usepackage{float}
\usepackage{changepage}
\usepackage[printonlyused,withpage]{acronym}
\usepackage{scalerel,stackengine}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usetikzlibrary{trees, shapes.geometric, arrows, fit}
\tikzstyle{host} = [rectangle, minimum width=1cm, minimum height=1cm, text width=3.5cm, draw=black]
\tikzstyle{arrow} = [thick,->,>=stealth, red]
% \bibliography{references.bib}
% \addbibresource{references.bib}
\theoremstyle{definition}
\newtheorem{definition}{Def}[section]
\def\apeqA{\SavedStyle\sim}
\def\apeq{\setstackgap{L}{\dimexpr.5pt+1.5\LMpt}\ensurestackMath{%
  \ThisStyle{\mathrel{\Centerstack{{\apeqA} {\apeqA} {\apeqA}}}}}}

% \title{IY5512 Summative CW}
% \author{Joshua Limbrey}
% \date{January 2022}

\begin{document}

\begin{titlepage}
    \begin{center}
        \Large
        \textbf{100912024}

        \vspace{0.1cm}
        \textbf{Joshua Limbrey}

        \vspace{5cm}
        \LARGE
        \textbf{Cryptanalysis of Lattice Based Post-Quantum Encryption Schemes}

        \vspace{0.1cm}
        \textbf{June 2022}

        \vspace{1.5cm}
        \textbf{Supervisor: Dr Rachel Player}

        \vfill

        Submitted as part of the requirements for the award of the\\MSc in Information Security\\at Royal Holloway, University of London.


        \vspace{2.5cm}

    \end{center}
\end{titlepage}

\tableofcontents

\newpage

\section{List of Definitions, Notation, Abbreviations and Acronyms}
\begin{acronym}
    \acro{CCA}{chosen ciphertext attack}
    \acro{CCA2}{adaptive chosen ciphertext attack}
    \acro{CPA}{chosen plaintext attack}
    \acro{KEM}{key encapsulation mechanism}
    \acro{LWE}{learning with errors}
    \acro{LWR}{learning with rounding}
    \acro{NIST}{National Institute of Standards and Technology}
    \acro{PKE}{public-key encryption}
    \acro{IND}{indistinguishability of ciphertexts}
    \acro{CVP}{closest vector problem}
    \acro{SVP}{shortest vector problem}
\end{acronym}

\begin{definition}[\ac{PKE} Scheme]
    Let $\Sigma$ be a \ac{PKE} encryption scheme, consisting of the following three algorithms:
    \begin{itemize}
        \item $KeyGen$\\ \textbf{Output}: $(pk, sk)$, where $pk$ is the public key and $sk$, the private key.
        \item $Enc$\\ \textbf{Input}: $pk$ and $m$, where $pk$ is as defined above and $m$ is the plaintext message to be encrypted. \\
        \textbf{Output}: $c$, the ciphertext.
        \item $Dec$\\ \textbf{Input}: $sk$ and $c$ as defined above.\\
        \textbf{Output}: $m$, the plaintext.
    \end{itemize}
    $\Sigma$ must also satisfy a correctness condition:
    \[\forall m \in \mathcal{M} \text{ and } \forall (pk, sk) \leftarrow \Sigma .KeyGen\]
    \[\Sigma .Dec_sk(\Sigma .Enc_pk(m)) = m\]
\end{definition}

\textbf{Note:} All security properties discussed will be for \ac{PKE} schemes.

\begin{definition}[Indistinguishable]
    \[(pk, sk) \leftarrow \Sigma.KeyGen \]
    An adversary $\mathcal{A}$ produces two messages $m_0, m_1 \in \mathcal{M}$ (of equal length).
    We choose a bit $b \in \{0,1\}$.
    \[c = \Sigma .Enc_{pk}(m_b)\] 
    Give the adversary $(c, pk)$, and allow them to generate a bit $a \in \{ 0,1\}$. If $a=b$, then the adversary has succeeded.\\
    We say an encryption scheme $\Sigma$ is indistinguishable if the following holds:
    \[\mathbb{P}(\mathcal{A} \text{ succeeds}) = \frac{1}{2} + \varepsilon \text{\qquad where $\varepsilon $ is negligible.}\] 
    Intuitively, an encryption scheme has indistinguishability if an adversary is given a challenge ciphertext $c$, they cannot tell if it is from $m_0$ or $m_1$.
\end{definition}
\begin{definition}[IND-CPA or CPA security]
    ``Indistinguishability of ciphertexts under chosen plaintext attack" for an encryption scheme $\Sigma $.\\
    \[(pk, sk) \leftarrow \Sigma.KeyGen \]
    The adversary $\mathcal{A} $ is given $pk$ and outputs two messages $m_0, m_1$ (of equal length), and is also given a challenge ciphertext:
    \[c=\Sigma .Enc_{pk}(m_b)\text{\qquad for a chosen }b \in \{ 0,1\}.\] 
    $\mathcal{A}$ now generates a bit $a \in \{ 0,1\}$, and if $a=b$ then $\mathcal{A}$ has succeeded.\\
    The encryption scheme has CPA security if:
    \[\mathbb{P} (\mathcal{A} \text{ succeeds}) = \frac{1}{2} + \varepsilon\text{\qquad where $\varepsilon$ is negligible.}\]
    This can intuitively be thought of as if an attacker is given access to the public key (therefore able to encrypt plaintext's of their choice \textbf{but not decrypt}), then if given the encryption of one of two plaintexts, the attacker has negligible advantage over guessing.
\end{definition}
\begin{definition}[IND-CCA or CCA security]
    ``Indistinguishability of ciphertexts under a chosen ciphertext attack" for an encryption scheme $\Sigma $.\\
    \[(pk, sk) \leftarrow \Sigma.KeyGen \]
    The adversary $\mathcal{A} $ is given $pk$ and a decryption oracle $\mathcal{O}_{\Sigma .Dec_{sk}}$, and outputs $m_0, m_1$ (of equal length). The adversary is only able to query this oracle up until it receives the challenge ciphertext,
    \[c=\Sigma .Enc_{pk}(m_b)\text{\qquad for a chosen }b \in \{ 0,1\}.\] 
    $\mathcal{A} $ then generates a bit $a \in \{ 0, 1\}$, and if $a=b$ then $\mathcal{A} $ has succeeded.
    The encryption scheme has CCA security if:
    \[\mathbb{P} (\mathcal{A} \text{ succeeds}) = \frac{1}{2} + \varepsilon \text{\qquad where $\varepsilon$ is negligible.}\]
    Intuitively, this is if an adversary is able to ask for decryptions before given the challenge, once given the challenge ciphertext they have negligible advantage over guessing.
\end{definition}
\begin{definition}[IND-CCA2 or CCA2 security]
    ``Indistinguishability of ciphertexts under an adaptive chosen ciphertext attack" for an encryption scheme $\Sigma $.\\
    \[(pk, sk) \leftarrow \Sigma.KeyGen \]
    The adversary $\mathcal{A} $ is given $pk$ and a decryption oracle $\mathcal{O}_{Dec_{sk}}$, and outputs $m_0, m_1$ (of equal length). The adversary then receives the challenge ciphertext,
    \[c=\Sigma .Enc_{pk}(m_b)\text{\qquad for a chosen }b \in \{ 0,1\}.\]
    but may continue to query $\mathcal{O}_{Dec_{sk}}$ provided the requested decryption is not of $c$
    $\mathcal{A} $ then generates a bit $a \in \{ 0, 1\}$, and if $a=b$ then $\mathcal{A} $ has succeeded.
    The encryption scheme has CCA security if:
    \[\mathbb{P} (\mathcal{A} \text{ succeeds}) = \frac{1}{2} + \varepsilon \text{\qquad where $\varepsilon$ is negligible.}\]
    Intuitively, this can be thought of as if an adversary has the ability to decrypt any ciphertext other than the challenge, can they decrypt the challenge.
\end{definition}

\textbf{Note:} We shall use $\mathcal{B} $ to denote the set of 8-bit unsigned integers (or bytes), ie. the set $\{0, ..., 255\}$



\newpage


\section{Understanding the LWE problem}

\textsc{Kyber}.\ac{PKE} is a module \ac{LWE} based encryption scheme; relying on the hardness of the of the \ac{LWE} problem -  believed to be hard for both classical and quantum computers, first introduced by O. Regev ***cite regev lwe****. Below is an informal mod $q$ set-up for the \ac{LWE} problem for a prime $q$:

\begin{enumerate}
    \item Let us chose an $n$ dimensional vector $\mathbf{s} \in \mathbb{F}^n_q$. This is our secret.
    \item Let us randomly and uniformly generate an $m\times n$ matrix $\mathbf{A} $ over $\mathbb{F}_q$ from elements in $\mathbb{F} _q$.
    \item Let us generate an $m$ dimensional vector, $\mathbf{e}$, s.t. $\mathbf{e}_i\sim \chi$ for all $i \in {1,...,m}$ independently for the distribution $\chi$ on $\mathbb{F}_q$ centred on $0$ with a small variance.
    \item Let $\mathbf{b} = \mathbf{A}\mathbf{s}+\mathbf{e}$ over $\mathbb{F}_q^m$
\end{enumerate}

Now, given $(\mathbf{A},\mathbf{b})$, find $\mathbf{s}$. Alternatively, the problem may be stated as given $(\mathbf{A},\mathbf{b})$, determine if $(\mathbf{A},\mathbf{b})$ was generated from our LWE set-up or uniformly at random. This problem can be reduced to solving the lattice problems \ac{SVP} or \ac{CVP}.\par  

First we consider the  $q$-ary lattice
\[\mathcal{L}_{Im(\mathbf{A})}=\{y \in \mathbb{Z}^m | y=\mathbf{A}z\mod{q} \mbox{ for some } z \in \mathbb{Z}^n \}\]
from the image of our matrix $\mathbf{A}$, $Im(\mathbf{A})={\mathbf{A}x|x\in \mathbb{F}_q^n}$, which we can see has the volume
\[Vol(\mathcal{L}_Im(\mathbf{A}))=q^{m-n}\text{.}\]

This lattice is generated by the column vectors of our matrix $\mathbf{A}\mod{q}$. From here, we can find our $m \times m$ basis matrix, $\textbf{B}_{Im(\textbf{A})}$ through the reduction of the $(n+m) \times m$ matrix
\[\mathbf{A}^T_q = (\frac{\mathbf{A}^T}{q\mathbf{I}_m})\]

\begin{definition}[Shortest Vector Problem \ac{SVP}]
    Given a lattice $\mathcal{L}$ with basis matrix $\textbf{B}$, find a non-zero vector $\mathbf{v} \in \mathcal{L}$ such that the length, $|\mathbf{v}|$, is minimal.
\end{definition}

\begin{definition}[Closest Vector Problem \ac{CVP}]
    Given a lattice $\mathcal{L}$ with basis matrix $\textbf{B}$, and a vector $\mathbf{v} \in \mathbb{R}^n$, find a vector $\mathbf{v} \in \mathcal{L}$ such that $|\mathbf{v} - \mathbf{w}|$ is minimal.
\end{definition}

Therefore, we can see that given $(\mathbf{A}, \mathbf{b})$ from an LWE problem, we can use these to generate a lattice $\mathcal{L}_{Im(\mathbf{A})}$. Then by finding the closest point to $\mathbf{b} = \mathbf{As} + \mathbf{e}$, we can find $\mathbf{s}$ (the closest vector to $\mathbf{b}$ should be $\mathbf{As}$ given $\mathbf{e}$ is small enough) - solving the LWE problem if CVP can be solved.
% \cite{LWR}.

\newpage

\section{Algorithm specification of \textsc{Kyber}.PKE}

\textsc{Kyber}.PKE is defined over the ring $R \equiv \mathbb{Z} /(X^n+1)$ and $R_q\equiv \mathbb{Z}_q[X]/(X^n+1)$ where $n=2^{n'-1}$ s.t. $X^{n}+1$ is the $2^{n'}$\textsuperscript{th} cyclotomic polynomial [citecrystals]. In relation to our earlier explained LWE problem, $R$ is $\mathbb{F}$ and $R_q$ is $\mathbb{F}_q$. We begin, by generating our matrix $\mathbf{A}$ using the following algorithm:
\begin{algorithm}[H]
    \caption{Generate keys.}
    \begin{algorithmic}
    \State $N:=0$
    \State $(\rho, \sigma ):=G(d)$ \Comment Where G is a hash function s.t. $G:\mathcal{B}^* \rightarrow \mathcal{B}^{32}\times  \mathcal{B}^{32}$
    \For{$i\gets 0, k-1$}
        \For{$j\gets 0, k-1$}
            \State $\mathbf{A}:=Parse(XOF(\rho , j, i))$ \Comment This essentially generates a random $k\times k$ matrix over $R_q$ as $\rho$ is pseudorandom from the hash function $G()$.
        \EndFor
    \EndFor
    \For{$i\gets 0, k-1$}
        \State $\mathbf{s}:=CBD(PRF(\sigma ,N))$ \Comment Where CBD is a function outputting a polynomial in $R_q$ with the coefficients distributed central-binomially. $PRF$ is a pseudorandom function, $PRF:\mathcal{B}^{32} \times \mathcal{B} \rightarrow \mathcal{B}^*$.
        \State $N:=N+1$
    \EndFor
    \For{$i\gets 0, k-1$}
        \State $\mathbf{e}:=CBD(PRF(\sigma ,N))$
        \State $N:=N+1$
    \EndFor
    \State $\mathbf{s}:= NTT(\mathbf{s})$ \Comment Where NTT is a bijection mapping $f \in R_q$ to a polynomial with the coefficient vector.
    \State $\mathbf{e}:= NTT(\mathbf{e})$
    \State $\mathbf{b}:=\mathbf{As}+\mathbf{e}$
    \State \textbf{return} $\mathbf{A}$, $\mathbf{s}$, $\mathbf{b}$, $\mathbf{e}$
    \end{algorithmic}
\end{algorithm}

From this, we have our public and private keys, $pk:=(\mathbf{b}\mod{q})\| \rho $ and $sk:=\mathbf{s}\mod{q}$ (both encoded).

\begin{algorithm}[H]
    \caption{Encryption}
    \begin{algorithmic}
    \State \textbf{Input:} $pk$, $m \in \mathcal{B}^{32}$
    \State first we must extract $\mathbf{A}$ and $\mathbf{b}$ from $pk$.
    \State $\rho:=pk+12\cdot k\cdot \frac{n}{8}$ \Comment $\rho$ was simply appended to the end of $\mathbf{b}$ so we can extract it simply. As we now have $\rho$ we can re-construct $\mathbf{A}$ like we did in key generation.
    \For{$i\gets 0, k-1$}
        \For{$j\gets 0, k-1$}
            \State $\mathbf{A}^T:=Parse(XOF(\rho , i, j))$ 
        \EndFor
    \EndFor
    \For{$i\gets 0, k-1$}
        \State $\mathbf{r}:=CBD(PRF(r ,N))$ \Comment Where $r \in \mathcal{B}^{32}$ is a random coin.
        \State $N:=N+1$
    \EndFor
    \For{$i\gets 0, k-1$}
        \State $\mathbf{e}_1:=CBD(PRF(r ,N))$
        \State $N:=N+1$
    \EndFor
    \State $e_2:=CBD(PRF(r, N))$
    \State $\mathbf{r}:=NTT(\mathbf(r))$
    \State $\mathbf{u}:=NTT^{-1}(\mathbf{A}^T\circ \mathbf{r})+\mathbf{e}_1$
    \State $v:=NTT^{-1}(\mathbf{b}^T\circ \mathbf{r})+e_2 + m $
    \State \textbf{return} $(\mathbf{u}\|v)$
    \end{algorithmic}
\end{algorithm}

It is important that the ciphertext composes of two parts, only one of which is dependent on the message, so that the receiver has enough information in order to decrypt correctly.

\begin{algorithm}[H]
    \caption{Decryption}
    \begin{algorithmic}
    \State \textbf{Input:} $sk$, $c$
    \State $m:=v-NTT^{-1}(\mathbf{s}^T\circ NTT(\mathbf{u}))$
    \State \textbf{return} $m$
    \end{algorithmic}
\end{algorithm}

It may not be readily obvious why it is this decryption works:
\begin{align*}
    v-NTT^{-1}(\mathbf{s}^T\circ NTT(\mathbf{u})) &= NTT^{-1}(\mathbf{b}^T\circ \mathbf{r}+e_2+m)-NTT^{-1}(\mathbf{s}^T\circ NTT(\mathbf{u}))\\
    &=NTT^{-1}(\mathbf{b}^T\circ \mathbf{r}+e_2+m)-NTT^{-1}(\mathbf{s}^T\circ \mathbf{A}^T\circ \mathbf{r}+\mathbf{e}_1)\\
    &=NTT^{-1}(\mathbf{b}^T\circ \mathbf{r}+e_2+m-\mathbf{s}^T\circ \mathbf{A}^T\circ \mathbf{r}+\mathbf{e}_1)\\
    &=NTT^{-1}(( \mathbf{A} \circ \mathbf{s})^T \circ \mathbf{r} - (\mathbf{s}^T \circ \mathbf{A} ^T) \circ \mathbf{r} + \mathbf{e} ^T + \mathbf{e}_1 + e_2 + m)\\
    &=NTT^{-1}(m+\mathbf{e}^T+\mathbf{e}_1+e_2)
\end{align*}

Therefore, we decrypt each bit as 0 if it is closer to 0 than $\lfloor \frac{q}{2} \mod{q}\rfloor $, ****check and update**** otherwise we decrypt as 1.
% \section{Executive Summary}

% \newpage


    
% \nocite{*}
% \printbibliography
\end{document}